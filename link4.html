<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Fluctuations and Path Integrals</title>

    <!-- Importing a new, modern font: Space Mono -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">

    <!-- MathJax for LaTeX typesetting -->
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        /* Light theme default for a clean, scientific aesthetic */
        body {
            font-family: 'Space Mono', monospace;
            background-color: #f0f0f0; /* Light gray background */
            color: #111; /* Dark text */
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            overflow-x: hidden;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        /* --- Dark Theme Overrides --- */
        body.dark-theme {
            background-color: #1a1a2e; /* Deep blue/purple background */
            color: #e0f7fa; /* Light cyan text */
        }

        /* Container for the main content */
        .container {
            flex-grow: 1;
            padding: clamp(30px, 5vw, 50px);
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
            box-sizing: border-box;
            position: relative;
        }

        /* --- Main Text Section --- */
        .main-content h1 {
            font-family: 'Space Mono', monospace;
            font-size: clamp(3rem, 10vw, 7rem);
            line-height: 1;
            text-transform: uppercase;
            font-weight: 700;
            letter-spacing: 5px;
            color: #111; /* Dark color for light theme */
        }
        body.dark-theme .main-content h1 {
            color: #79a6fe; /* Bright accent color */
            text-shadow: 0 0 5px rgba(121, 166, 254, 0.5);
        }

        /* --- Tutorial Section Styles --- */
        .tutorial-content {
            margin-top: clamp(50px, 10vw, 100px);
            padding-top: clamp(25px, 5vw, 50px);
            border-top: 1px solid #ccc;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: clamp(20px, 5vw, 40px);
        }
        body.dark-theme .tutorial-content {
            border-top: 1px solid #334e68;
        }

        .tutorial-content p { line-height: 1.6; max-width: 800px; }
        .tutorial-content h2, .tutorial-content h3, .tutorial-content h4 { font-weight: 700; text-transform: uppercase; color: #333; }
        body.dark-theme .tutorial-content h2, body.dark-theme .tutorial-content h3, body.dark-theme .tutorial-content h4 { color: #b3ccff; }
        .tutorial-content h2 { font-size: clamp(1.5rem, 4vw, 2rem); letter-spacing: 2px; }
        .tutorial-content h3 { font-size: clamp(1rem, 2vw, 1.2rem); margin-top: 2rem; margin-bottom: 1rem; }

        pre { 
            background-color: #e5e7eb; 
            padding: 1.5rem; 
            border-radius: 0.5rem; 
            overflow-x: auto; 
            white-space: pre-wrap; 
            word-wrap: break-word; 
            width: 100%; 
            box-sizing: border-box; 
            border: 1px solid #ddd; 
        }
        body.dark-theme pre {
            background-color: #0f0f1a;
            border: 1px solid #334e68;
        }
        pre code { font-size: 0.9rem; color: #008080; /* Teal color for code text */ }
        body.dark-theme pre code { color: #a9f0a9; }

        /* Style for LaTeX equations */
        .equation-block {
            padding: 20px;
            margin: 1.5rem 0;
            border-left: 5px solid #007bff; /* Blue accent for light theme */
            background-color: #ffffff;
            border-radius: 4px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
        }
        body.dark-theme .equation-block {
            border-left: 5px solid #ff5757; /* Energy/action red accent */
            background-color: #252a42;
            box-shadow: 0 0 10px rgba(255, 87, 87, 0.2);
        }
        
        /* Specific MathJax styling for visibility */
        .MathJax { color: #111 !important; }
        body.dark-theme .MathJax { color: #fff !important; }

        /* Visualization Area */
        .viz-container {
            width: 100%;
            max-width: 800px;
            height: 400px; /* Fixed height for the canvas */
            margin: 20px auto;
            border: 2px solid #007bff;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 0 15px rgba(0, 123, 255, 0.3);
            background-color: #ffffff;
            position: relative;
        }
        body.dark-theme .viz-container {
            border: 2px solid #79a6fe;
            box-shadow: 0 0 20px rgba(121, 166, 254, 0.5);
            background-color: #0f0f1a;
        }

        #fluctuation-canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .viz-container figcaption {
            padding: 10px;
            font-size: 0.8rem;
            text-align: center;
            background-color: rgba(220, 220, 220, 0.8);
            color: #333;
        }
        body.dark-theme .viz-container figcaption {
            background-color: rgba(0, 0, 0, 0.3);
            color: #b3ccff;
        }


        /* --- Footer and Theme Toggle --- */
        footer {
            margin-top: auto;
            padding: 30px clamp(30px, 5vw, 50px);
            border-top: 1px solid #ccc;
            color: #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }
        body.dark-theme footer {
            border-top: 1px solid #334e68;
            color: #b3ccff;
        }

        .theme-toggle-button {
            background: none; border: 1px solid #111; color: #111; padding: 8px 16px;
            font-family: 'Space Mono', monospace; font-size: 0.9rem; cursor: pointer;
            transition: background-color 0.3s ease, color 0.3s ease; border-radius: 5px;
            display: flex; align-items: center; gap: 8px; text-transform: uppercase;
        }

        .theme-toggle-button:hover { background-color: #111; color: #f0f0f0; }

        body.dark-theme .theme-toggle-button {
            border: 1px solid #f0f0f0;
            color: #f0f0f0;
        }
        body.dark-theme .theme-toggle-button:hover {
            background-color: #f0f0f0;
            color: #111;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .container { padding: 20px; text-align: center; align-items: center; }
            .main-content h1 { letter-spacing: 2px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Main content area -->
        <div class="main-content">
            <h1>QFT PATH INTEGRALS</h1>
        </div>

        <!-- Tutorial Section (Core Technical Content) -->
        <main class="tutorial-content">
            <h2 class="books-title">Quantum Fluctuations: The Ephemeral Vacuum</h2>
            <p>
                In Quantum Field Theory (QFT), the "vacuum" is not empty but a dynamic medium constantly undergoing **quantum fluctuations**. These fluctuations manifest as the spontaneous, transient creation and annihilation of particle-antiparticle pairs (virtual particles) across the entire spacetime. This phenomenon is mathematically described by fundamental concepts like the Action and the Feynman Path Integral.
            </p>

            <h3 id="visualization">1. Conceptual Visualization</h3>
            <p>
                The visualization below represents a slice of the quantum vacuum. Particles (represented by glowing dots) briefly appear and disappear, governed by the uncertainty principle, where energy $\Delta E$ and time $\Delta t$ are inversely related ($\Delta E \Delta t \ge \hbar/2$). 
            </p>

            <!-- Visualization Canvas -->
            <div class="viz-container">
                <canvas id="fluctuation-canvas"></canvas>
                <figcaption>Simulated activity of virtual particle creation and annihilation in the quantum vacuum.</figcaption>
            </div>
            <!-- End Visualization -->

            <h3 id="qft-math">2. Core Quantum Field Theory Mathematics</h3>

            <h4 id="the-action">The Action $S[\phi]$ (Classical Input)</h4>
            <p>
                The dynamics of a quantum field $\phi$ (like the electromagnetic or scalar field) are determined by the Lagrangian density, which integrates over spacetime to define the Action $S[\phi]$. This classical concept is the central input for the path integral. The general form for a scalar field $\phi$ is:
            </p>
            <div class="equation-block">
                $$
                S[\phi] = \int d^4x \left( \frac{1}{2} (\partial_\mu \phi)^2 - \frac{1}{2} m^2 \phi^2 - V(\phi) \right)
                $$
                <p class="text-xs mt-3">Where $d^4x$ is the spacetime volume element, $(\partial_\mu \phi)^2$ is the kinetic term, $m$ is the mass, and $V(\phi)$ is the interaction potential.</p>
            </div>

            <h4 id="feynman-integral">The Feynman Path Integral</h4>
            <p>
                The Feynman Path Integral provides a framework where the probability amplitude for a particle (or field) to go from point A to point B is a sum over all possible paths, weighted by the exponential of the classical action. In QFT, it's used to calculate the vacuum expectation value (VEV) of field operators, like $n$-point correlation functions (Green's functions).
            </p>
            <p>
                This Green's function, $\langle 0 | T(\hat{\phi}(x_1) \dots \hat{\phi}(x_n)) | 0 \rangle$, is proportional to the probability of observing $n$ particles at $n$ spacetime points ($x_1$ through $x_n$), accounting for all quantum fluctuations:
            </p>
            <div class="equation-block">
                $$
                \langle 0 | T(\hat{\phi}(x_1) \dots \hat{\phi}(x_n)) | 0 \rangle = \frac{\int \mathcal{D}\phi \, \phi(x_1) \dots \phi(x_n) e^{iS[\phi]/\hbar}}{\int \mathcal{D}\phi \, e^{iS[\phi]/\hbar}}
                $$
                <p class="text-xs mt-3">
                    The expression $\int \mathcal{D}\phi$ represents the "sum over all possible field configurations" (paths), and the denominator is a normalization factor known as the partition function.
                </p>
            </div>

            <h3 id="sim-code">3. Conceptual QFT Simulation Code (Lattice Field Theory)</h3>
            <p>
                Since solving the continuous Path Integral analytically is often impossible, numerical methods like Lattice Field Theory discretize spacetime into a finite grid (lattice) and use Monte Carlo techniques to evaluate the high-dimensional integral. This C++ conceptual code snippet illustrates the main loop for sampling field configurations.
            </p>
            <pre class="code-snippet"><code class="language-cpp">// conceptual_lattice_qft.cpp: Conceptual C++ Monte Carlo Loop
#include <iostream>
#include <vector>
#include <cmath>
#include <random>

// Define Lattice Parameters
const int LATTICE_SIZE = 16 * 16 * 16 * 4; // 4D Spacetime: x, y, z, t
const double MASS_SQUARED = 0.1;           // m^2
const double COUPLING_LAMBDA = 0.5;        // Interaction strength (lambda * phi^4)

/**
 * @brief Calculate the total Action (S) for a given field configuration.
 * The Action is discretized on the lattice (Euclidean space).
 * * @param field The field configuration (array of phi values at each site).
 * @return double The discretized Action S.
 */
double calculate_action(const std::vector<double>& field) {
    double action = 0.0;
    
    // --- 1. Kinetic Term (Gradient/Derivative Approximation) ---
    // This part involves calculating the difference between adjacent sites.
    // Conceptual approximation for simplicity:
    for (int i = 0; i < LATTICE_SIZE; ++i) {
        // Assume d_mu phi ~ phi[i] - phi[neighbor]
        // This is highly simplified; a real code uses neighbor indexing (shift operations)
        action += 0.5 * field[i] * field[i] * 4; // Simplified neighbor contribution
    }

    // --- 2. Mass and Interaction Terms (Local to the site) ---
    for (int i = 0; i < LATTICE_SIZE; ++i) {
        double phi = field[i];
        action += 0.5 * MASS_SQUARED * phi * phi;    // Mass term (m^2 phi^2)
        action += (COUPLING_LAMBDA / 24.0) * pow(phi, 4); // Interaction term (lambda phi^4)
    }

    return action;
}

void monte_carlo_step(std::vector<double>& field, std::mt19937& rng) {
    std::uniform_real_distribution<> dist(0.0, 1.0);
    double initial_action = calculate_action(field);
    
    // Iterate over all sites (x) in the 4D lattice
    for (int site = 0; site < LATTICE_SIZE; ++site) {
        double phi_old = field[site];
        
        // Propose a local change (fluctuation) at this site
        double delta_phi = (dist(rng) - 0.5) * 0.5; // Small random change
        field[site] += delta_phi;
        
        double new_action = calculate_action(field); // Recalculate full action (optimization is key here!)
        double delta_S = new_action - initial_action;

        // Metropolis Acceptance Criterion: e^(-Delta S)
        if (delta_S < 0 || dist(rng) < exp(-delta_S)) {
            // Accept the change (Field has fluctuated to a new, lower-action state)
            initial_action = new_action;
        } else {
            // Reject the change (Revert the fluctuation)
            field[site] = phi_old;
        }
    }
}

int main() {
    std::vector<double> field(LATTICE_SIZE, 0.0); // Initialize field (e.g., to zero)
    std::mt19937 rng(std::random_device{}());

    std::cout << "// --- Starting Lattice QFT Simulation (Monte Carlo) --- \n";
    std::cout << "// Sampling field configurations to calculate Feynman Integral...\n";

    for (int sweep = 0; sweep < 1000; ++sweep) {
        monte_carlo_step(field, rng);
        
        // After many sweeps, measure correlation functions:
        if (sweep % 100 == 0) {
            std::cout << "Sweep " << sweep << ": Action = " << calculate_action(field) << "\n";
            // *** MEASUREMENT STEP HERE: Evaluate integral terms like: ***
            // double two_point = field[x1] * field[x2];
            // total_two_point += two_point;
        }
    }

    std::cout << "// Simulation finished. Correlation functions are now averaged.\n";
    return 0;
}
// End of C++ conceptual code.</code></pre>

        </main>
    </div>

    <!-- The Footer remains outside the container to span full width -->
    <footer>
        <p>Â© 2025 QFT Technical Document. (Path Integrals Edition)</p>
        <!-- Theme Toggle Button -->
        <button id="theme-toggle" class="theme-toggle-button">
            <!-- SVG icon for sun/light mode -->
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
            <span id="theme-text">Dark Mode</span>
        </button>
    </footer>

    <!-- JavaScript for Visualization (Conceptual Particle Spawning) and Theme Toggle -->
    <script>
        const canvas = document.getElementById('fluctuation-canvas');
        const ctx = canvas.getContext('2d');
        let particles = [];
        const MAX_PARTICLES = 30;
        const body = document.body;

        // --- Theme Toggle Logic ---
        const toggleButton = document.getElementById('theme-toggle');

        function updateThemeUI(isDark) {
            const themeText = document.getElementById('theme-text');
            if (isDark) {
                body.classList.add('dark-theme');
                themeText.textContent = 'Light Mode';
                toggleButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg><span>${themeText.textContent}</span>`;
            } else {
                body.classList.remove('dark-theme');
                themeText.textContent = 'Dark Mode';
                toggleButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg><span>${themeText.textContent}</span>`;
            }
        }

        // Apply saved theme or default to light
        const savedTheme = localStorage.getItem('theme');
        updateThemeUI(savedTheme === 'dark');

        toggleButton.addEventListener('click', () => {
            const isDark = !body.classList.contains('dark-theme');
            localStorage.setItem('theme', isDark ? 'dark' : 'light');
            updateThemeUI(isDark);
        });

        // --- Visualization Logic ---
        function resizeCanvas() {
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        class Particle {
            constructor(x, y, isAnti) {
                this.x = x;
                this.y = y;
                this.radius = Math.random() * 1.5 + 1;
                this.life = Math.random() * 150 + 50; // Ticks until annihilation
                this.opacity = 0;
                this.fadeRate = 0.02;
                this.isAnti = isAnti;
                this.color = isAnti ? 'rgba(255, 60, 60, ' : 'rgba(0, 150, 255, '; // Red/Blue pair
                this.vx = (Math.random() - 0.5) * 0.5;
                this.vy = (Math.random() - 0.5) * 0.5;
            }

            update() {
                this.life--;
                
                if (this.life > 100) {
                    // Phase 1: Creation (Fade In)
                    this.opacity = Math.min(this.opacity + this.fadeRate, 0.8);
                } else if (this.life < 50) {
                    // Phase 2: Annihilation (Fade Out)
                    this.opacity = Math.max(this.opacity - this.fadeRate, 0);
                    this.radius *= 0.98; // Shrink
                } else {
                    // Phase 3: Exist
                    this.opacity = 0.8;
                }
                
                this.x += this.vx;
                this.y += this.vy;
                
                // If opacity hits zero and life is done, particle is removed
                return this.opacity > 0 || this.life > 0;
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
                ctx.fillStyle = this.color + this.opacity + ')';
                ctx.shadowColor = this.color + (this.opacity * 0.5) + ')';
                ctx.shadowBlur = this.radius * 2;
                ctx.fill();
            }
        }

        function createPair() {
            if (particles.length < MAX_PARTICLES) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                
                // Spawn particle and antiparticle close to each other
                particles.push(new Particle(x, y, false));
                particles.push(new Particle(x + (Math.random() - 0.5) * 5, y + (Math.random() - 0.5) * 5, true));
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Background trace effect is dependent on the theme
            if (body.classList.contains('dark-theme')) {
                ctx.fillStyle = 'rgba(26, 26, 46, 0.1)'; // Dark trace
            } else {
                ctx.fillStyle = 'rgba(240, 240, 240, 0.1)'; // Light trace
            }
            ctx.fillRect(0, 0, canvas.width, canvas.height); 

            particles = particles.filter(p => p.update());

            particles.forEach(p => p.draw());

            // Randomly create a new pair
            if (Math.random() < 0.05) { // 5% chance per frame to spawn
                createPair();
            }
        }

        // Start the quantum fluctuation visualization
        animate();
    </script>
</body>
</html>